# 3. Refactoring the Store Class

In this step, you will refactor (change) the Store class so that it no longer uses a primitive array, but uses an ArrayList instead.


## Import the ArrayList class

To use the ArrayList in our Store class, we need to import it:

~~~
import java.util.ArrayList;
~~~


## Declaring an ArrayList

Currently we are using a primitive array and we keep track of how many items are added using the `total` field:

~~~
	private Product[] products;
	private int total = 0;
~~~

As an ArrayList automatically grows and shrinks as you add/remove elements, there is no need for the **total** field anymore. Delete this field.

The `products` instance field should also be changed to this:

~~~
    private ArrayList<Product> products;
~~~


## The Store Constructor

Currently the Store constructor looks like this:

~~~
	public Store(int numberItems){
		products = new Product[numberItems];
	}
~~~

As an ArrayList doesn't need to know the maximum number of items that will be stored, we can delete the parameter **numberItems**.  We will instantiate the **products** ArrayList too, instead of a primitive array instantiation.  Your constructor should now look like this:

~~~
	public Store(){
		products = new ArrayList<Product>();
	}
~~~


## The add method

Currently the **add** method looks something like this (see code below).  As a primitive array has a maximum capacity, we have to check if the array is full before attempting to add a Product to it.  As the add can fail due to space restrictions, we also needed to return a boolean status for the add.  The total field also needed to be maintained.

~~~
    public boolean add(Product product) {
        if (isFull()) {
            return false;
        } else {
            products[total] = product;
            total++;
            return true;
        }
    }
~~~

As the ArrayList grows when you add `Product` objects to it, you don't need to check for spare capacity nor do you have to maintain the total items entered (an ArrayList does this for us).  Replace the above **add** method with our new **add** method, which will simply look like this:

~~~
    public boolean add (Product product){
        return products.add (product);
    }
~~~

Note that we are returning the result for the ArrayList `add` method to the Driver; if something went wrong, we will be sent back a `false` value, otherwise a `true`.  Then the Driver class can let the user know if the add was successful or not based on this return value.


## The listProducts method

Currently the **listProducts** method for our primitive array looks like this:

~~~
    public String listProducts() {
        if (isEmpty()) {
            return "No products in the store";
        } else {
            String listOfProducts = "";
            for (int i = 0; i < total; i++) {
                listOfProducts += i + ": " + products[i] + "\n";
            }
            return listOfProducts;
        }
    }
~~~

Rewrite the method so that it handles an ArrayList instead and looks like this:

~~~
    public String listProducts() {
        if (products.isEmpty()) {
            return "No products in the store";
        } else {
            String listOfProducts = "";
            for (int i = 0; i < products.size(); i++) {
                listOfProducts += i + ": " + products.get(i) + "\n";
            }
            return listOfProducts;
        }
    }
~~~

Or if you prefer to use the for-each loop, you can replace it with this:

~~~
    public String listProducts(){
	    if (products.isEmpty()) {
            return "No products in the store";
        } else {
			String listOfProducts = "";
			int index = 0;
			for (Product product : products){
				listOfProducts += index + ": " + product + "\n";
				index ++;
			}
			return listOfProducts;
		} 
	}
~~~


## The listCurrentProducts method

Having rewritten the **listProducts** method, refactor the **listCurrentProducts** method body so that it is the exact same.

Then include, inside the for loop, the following test so that only those products in the current product line are added to the String to be returned:

~~~
    if (products.get(i).isInCurrentProductLine())
~~~


If you need help with this method refactoring, the code for the fully refactored Store class is at the bottom of this page.


## The listProductsAboveAPrice method

Having worked on the other two **list** methods above, have a go at converting **listProductsAboveAPrice** to handle an **ArrayList** instead of a **primitive array**.


##The averageProductPrice method

Currently, the **averageProductPrice** method looks like this:

~~~java
    public double averageProductPrice() {
        if (!isEmpty()) {
            double totalPrice = 0;
            for (int i = 0; i < total; i++) {
                totalPrice += products[i].getUnitCost();
            }
            return totalPrice / total;
        } else {
            return -1;
        }
    }
~~~

Refactor the method so that it looks like the code below.  Note that we have catered for an empty ArrayList...we don't want to accidentally divide by zero as it will crash our program (with a DivideByZeroException).

~~~
    public double averageProductPrice() {
        if (!products.isEmpty()) {
            double totalPrice = 0;
            for (Product product : products) {
                totalPrice += product.getUnitCost();
            }
            return totalPrice / products.size();
        } else {
            return -1;
        }
    }
~~~


## The cheapestProduct method

Having refactored the previous methods, have a go at converting the **cheapestProduct** method to handle an **ArrayList** instead of a **primitive array**.


## isEmpty and isFull methods

There is no need for these methods when using ArrayLists, so you can simply delete them.


## Refactored Store Class

The fully refactored Store class is here, should you need it:

~~~
import java.util.ArrayList;

public class Store {

    private ArrayList<Product> products;

    public Store(){
        products = new ArrayList<Product>();
    }

    public boolean add (Product product){
        return products.add (product);
    }

    public String listProducts() {
        if (products.isEmpty()) {
            return "No products in the store";
        } else {
            String listOfProducts = "";
            for (int i = 0; i < products.size(); i++) {
                listOfProducts += i + ": " + products.get(i) + "\n";
            }
            return listOfProducts;
        }
    }

    public Product cheapestProduct() {
        if (!products.isEmpty()) {
            Product cheapestProduct = products.get(0);
            for (Product product : products) {
                if (product.getUnitCost() < cheapestProduct.getUnitCost())
                    cheapestProduct = product;
            }
            return cheapestProduct;
        } else {
            return null;
        }
    }

    public String listCurrentProducts() {
        if (products.isEmpty()) {
            return "No Products in the store";
        } else {
            String listOfProducts = "";
            for (int i = 0; i < products.size(); i++) {
                if (products.get(i).isInCurrentProductLine())
                    listOfProducts += i + ": " + products.get(i) + "\n";
            }
            if (listOfProducts.equals("")){
                return "No Products are in our current product line";
            }
            else{
                return listOfProducts;
            }
        }
    }

    public double averageProductPrice() {
        if (!products.isEmpty()) {
            double totalPrice = 0;
            for (Product product : products) {
                totalPrice += product.getUnitCost();
            }
            return totalPrice / products.size();
        } else {
            return -1;
        }
    }

    public String listProductsAboveAPrice(double price) {
        if (products.isEmpty()) {
            return "No Products in the store";
        } else {
            String str = "";
            for (int i = 0; i < products.size(); i++) {
                if (products.get(i).getUnitCost() > price)
                    str += i + ": " + products.get(i) + "\n";
            }
            if (str.equals("")) {
                return "No products are more expensive than: " + price;
            } else {
                return str;
            }
        }
    }

}
~~~